David Rodríguez Bacelar (david.rbacelar@udc.es)
Anxo Portela Iglesias (anxo.portela.iglesias@udc.es)

=============================================

## INTRODUCCIÓN:

## En este informe se analizará la complejidad de3 algoritmos que calculan el n-ésimo elemento de la sucesión de Fibonacci, calculando sus tiempos de ejecución (en µs).
 
## Para realizar las pruebas se utilizó un Lenovo-Legion Y540 con las siguientes especificaciones:
	- Procesador Intel® Core™ i5-9300H @ 2.40GHz × 8.
	- Memoria RAM DDR4 de 16 GB (2x8 GB) a 2666 MHz.
	- Sistema Operativo GNU/LINUX Ubuntu v20.04.1 LTS 64bit.
	
## En primer lugar y para comprobar el correcto funcionamiento de los 3 algoritmos, se utilizó una función "test" que mostraba los 20 primeros números de la sucesión.

        n       fib1       fib2       fib3

        1          1          1          1
        2          1          1          1
        3          2          2          2
        4          3          3          3
        5          5          5          5
        6          8          8          8
        7         13         13         13
        8         21         21         21
        9         34         34         34
       10         55         55         55
       11         89         89         89
       12        144        144        144
       13        233        233        233
       14        377        377        377
       15        610        610        610
       16        987        987        987
       17       1597       1597       1597
       18       2584       2584       2584
       19       4181       4181       4181
       20       6765       6765       6765
       
       
=============================================

## RESULTADOS:

AVISO: Recalcar que para obtener una tabla con valores más estables, se repitió cada prueba 5 veces, escogiendo finalmente aquella con una variabilidad menor en los tiempos.

## Para analizar el primero de los algoritmos, el número de entrada varía entre 2 y 32 (ya que el tiempo de ejecución a partir de ese valor se dispara) con saltos de potencias de 2. En este caso:
	· La cota subestimada f(n) = 1.1^n
	· La cota ajustada g(n) = φ^n donde φ = (1+√5)/2
	· La cota sobreestimada h(n) = 2^n.1

- - - - - - - - - - Fib1 - - - - - - - - - - - - - - - - - - - - - - -


         n           t(n)      t(n)/f(n)      t(n)/g(n)      t(n)/h(n)
*        2          0.006       0.004760      0.0022001     0.00144000
*        4          0.015       0.010136      0.0021651     0.00092750
*        8          0.110       0.051311      0.0023413     0.00042965
*       16          5.307       1.154990      0.0024047     0.00008098
        32      11875.000     562.428984      0.0024380     0.00000276

Notas:
	- *: Tiempo promedio en µs de K1 = 100.000 ejecuciones para tiempos por debajo del umbral de confianza (t = 500 µs).
	- La relación entre t(n) y g(n) (la cota ajustada) se aproxima a una constante C ϵ (0.002165, 0.002438).
	
CONCLUSIÓN: t(n) = O(φ^n).


=============================================
 
 
## En el segundo, el número de entradas varía entre 1.000 y 10.000.000 con saltos de potencias de 10. Para este otro caso:
	· La cota subestimada f(n) = n^0.8
	· La cota ajustada g(n) = n
	· La cota sobreestimada h(n) = n*log(n)

- - - - - - - - - - Fib2 - - - - - - - - - - - - - - - - - - - - - - -


         n           t(n)      t(n)/f(n)      t(n)/g(n)      t(n)/h(n)
*     1000          2.609       0.010387      0.0026090     0.00037769
*    10000         26.302       0.016595      0.0026302     0.00028557
*   100000        262.880       0.026288      0.0026288     0.00022833
   1000000       2625.000       0.041603      0.0026250     0.00019000
  10000000      26304.000       0.066073      0.0026304     0.00016320

Notas:
	- *: Tiempo promedio en µs de K2 = 1.000 ejecuciones para tiempos por debajo del umbral de confianza (t = 500 µs).
	- La relación entre t(n) y g(n) (la cota ajustada) se aproxima a una constante C ϵ (0.002609, 0.002630).
	
CONCLUSIÓN: t(n) = O(n).
	
	
=============================================
 
 
## Finalmente, el número de entradas en el último algoritmo varía igualmente entre 1.000 y 10.000.000 con saltos de potencias de 10. Para este caso:
	· La cota subestimada f(n) = √log(n)
	· La cota ajustada g(n) = log(n)
	· La cota sobreestimada h(n) = n^0.5
	
- - - - - - - - - - Fib3 - - - - - - - - - - - - - - - - - - - - - - -


         n           t(n)      t(n)/f(n)      t(n)/g(n)      t(n)/h(n)
*     1000        0.03854       0.014664      0.0055792     0.00121874 @
*    10000        0.04686       0.015441      0.0050878     0.00046860
*   100000        0.05751       0.016949      0.0049953     0.00018186
*  1000000        0.06811       0.018324      0.0049300     0.00006811
* 10000000        0.07985       0.019889      0.0049541     0.00002525

Notas:
	- *: Tiempo promedio en µs de K3 = 100.000 ejecuciones para tiempos por debajo del umbral de confianza (t = 500 µs).
	- @: Medición anómala del tiempo de ejecución.
	- La relación entre t(n) y g(n) (la cota ajustada) se aproxima a una constante C ϵ (0.004930, 0.005088).
	
DISCUSIÓN: Para el cálculo del intervalo de C se omitió el tiempo de la primera ejecución del algoritmo ya que da un valor muy por encima de lo normal.
CONCLUSIÓN: t(n) = O(log(n)).
	
=============================================

## CONCLUSIONES FINALES:

Tras extraer las cotas ajustadas de los tres algoritmos, es obvio que la función t(n) del tercer algoritmo crece
de una forma mucho más lenta que el resto de las funciones (complejidad logarítmica) haciendo posible el cálculo de elementos muy grandes de la sucesión de Fibonacci.

Además, atendiendo a los datos reflejados en las pruebas, se observa claramente que el primer algoritmo Fib1, de complejidad 
exponencial, es muy poco eficiente en comparación con los otros dos. Aún así, y a pesar de la gran velocidad en la obtención de los 
elementos de la sucesión del tercer algoritmo Fib3, su complicada implementación puede llegar a perjudicar la comprensión, reutilización y 
mantenimiento del código. Por lo tanto, creemos que el algoritmo Fib2 proporciona un buen balance entre rendimiento (complejidad lineal) y legibilidad.
	
	
	
	
	
	
	
	
	
	
